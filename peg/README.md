# 『Pythonで学ぶ解析表現文法と構文解析』読書ノート

## 第1章 構文解析入門

### 例: 再帰下降構文解析法による数式パーザ

文字列全体を再帰関数で分割しながら構文木を作ることを再帰下降構文解析法（recursive descent parsing）と呼ぶ。トップダウン解析とも。

再帰下降構文解析法では解析順序により構文木の構造が決まる。つまり、正しい順序で処理しないと正しく構文解析できないため、難しい。

本文では具体的な難しさを簡単な数式解析プログラムで例示している。以下の難易度表が面白かった。

- `1+2+3` のように加算のみなら、再帰関数の例題レベル
- `1+2*3` のように四則演算のみなら、先読みでなんとかなる
- `(1+2)*3` のようにグループ化が入ると、プログラミングコンテスト出題レベル
- `f(x)+1` のように変数・関数が加わると、プログラミングする気がなくなるレベル

実用的なコンパイラは基本的に再帰下降構文解析で書かれている。GCCやClangといったところ。原理的に再帰下降構文解析で書けないものはないが、超人的な努力が必要。「頑張ってプログラミングする」は科学ではない。再帰下降構文解析より体系的で楽な手法が必要。ここまでが話の枕。

## 第2章 パターンで考える

BNFの紹介。式を生成するための規則を考える。たとえば `1+2` であれば `<値>"+"<値>` の並びがある、という風に。`<>` で囲まれた変数を非終端記号と呼ぶ。非終端記号は `<値> ::= "1" | "2" | "3"` のように内容を定義する。`"+"` や `"1"` のようなリテラルを非終端記号と呼ぶ。非終端記号や終端記号を表す囲み文字は本書特有のものであるため `<>`, `""` でないとダメということはない。

BNFは文脈自由文法に基づいて設計されている。BNFで書いたパターンにマッチすればその文字列が生成可能と言える。一般化したい場合、たとえば任意の四則演算を生成するBNFを作りたい場合、式の非終端記号を定義する際に再帰を使う必要がある。

コラムの再帰が現実にも現れる例（アメリカ市民の定義）がなるほどと思った。

拡張BNF（Extended-BNF, EBNF）はBNFの文法に正規表現を追加して便利にしたもの。本書ではBNFとは区別せず、EBNFを使う。

BNFと再帰下降構文解析の実装はよく似ている。そこで「BNF→実装コードに変換するプログラムは作れないか？」という疑問が湧く。ここでBNFからパターンマッチする際の挙動を振り返る。これは非終端記号から終端記号にバラしていく作業である。これは構文解析の逆で、終端記号を非終端記号に置き換えていく作業である。そのため、BNFの生成規則の逆として簡約規則を導入する。これは生成規則の矢印を単に逆向きにするだけである。

簡約規則を適用して文字列を非終端記号1つに簡約することが構文解析といえる。つまり、BNFを利用すると文字列を構文木に機械的に変換できることがわかる（そのようなプログラムが存在する）。

簡約規則を適用すればOKなのだから簡単に思えるが、簡約規則を適用する順序が簡単に決められない。

簡約順序適用を決めるためのアルゴリズムとして、バックトラッキング法が定石として知られている。しかしBirmanとUllmanの研究により最悪指数計算時間が $O(2^N)$ となることが知られている。これは最悪指数時間問題と呼ばれている。解析表現文法を用いてもこの問題はつきまとう。

以上をまとめると、「BNFは再帰下降構文解析より簡単に文法を表現できるが、解析順序の難しさは変わらない（パーザを作るのは依然として難しい）」となる。解析表現文法が生まれた背景には、こうした問題がある。すなわち「BNFに解析順序を決める手段を追加したらどうなるか？」というアイデアである。

## 第3章 解析表現文法の登場

解析表現文法は2000年代初頭に当時MIT大学院生だったBryan Fordにより考案された。彼は少しの工夫でBNFに順序が定義可能なことに気づいたのである。

### BNFを使った開発と課題

通常、開発者はBNFを使って再帰下降構文解析を行う。その際、BNFに定義された構文を可能な限り機械的にコードに置き換える作業を行う。これはBNFとコードを対比させやすくし、コードのメンテナンス性を向上させるためである。

BNFにはコード化しづらい部分が存在する。`A | B` のような**選言（alternation）**がそれである。これは「AまたはBのどちらか」という意味で、マッチする順序は考慮されていない。つまりAかB好きな方にマッチしてよい。場合によってはAとB両方にマッチしてから都合のよい方を選ぶケースもある。このような曖昧さは開発者に苦労を強いる原因になっていた。

Fordは「**選言の代わりにプログラミング言語の論理和で構文を表現できないか？**」と考えた（論理和は短絡評価のため左側の値が先に計算される）。

解析表現文法の順序付き選択 `A / B` はBNFの選言 `A | B` の代わりに導入されたものである。順序付き選択は「まずAを判定し、Aが否定の場合のみBを判定する」という意味である。解析表現文法は大雑把に以下のようなものである。

$$解析表現文法 \thicksim BNF + 順序付き選択$$

### 左再帰問題

以下のような解析表現文法を考える。

```
Expr = Expr'+'Expr
     / Expr'*'Expr
     / Value

Value = [0-9]+
```

これを `1+2` にマッチすることを考えると、常に `Expr'+'Expr` が先にマッチしてしまい構文解析が終わらない。これを左再帰問題という。

解析表現文法では左再帰を除去し右再帰に置き換える必要がある。

```
Expr = Prod ( '+' Prod)*
Prod = Value ( '*' Value)*
Value = [0-9]+
```

左再帰を除去するのは面倒だが、手順が存在する（5章）。重要なのは、左再帰を除去することにより、BNFを元にした実装で必要だった後処理（disambiguation）が不要になり、曖昧さのない決定的な規則を記述しているという点である。

### 解析表現文法の記述力

言語の記述力はChomsky階層というものがある。

- 正規表現はポンプの補題によりカッコの対応が記述できない（プログラミング言語は作れない）
- 文脈自由文法はカッコの対応を記述できる（プログラミング言語も作れる）が、`{a^n b^n c^n | n >= 0}`を受理する構文は作れない
- 解析表現文法は以下の定義を考えると`{a^n b^n c^n | n >= 0}`を受理可能

```
S = &(A !'b') 'a' + B !.
A = 'a' A? 'b'
B = 'b' B? 'c'
```

`{a^n b^n c^n | n >= 0}`が受理可能な言語はChomsky階層において文脈依存言語に属すると考えられている。このため、解析表現文法は文脈自由文法の表現力を超えていると予想されている。

理論的な枠組みでは以上のように考えられているが、実務上もLALR(1)と同等の表現力があると考えられている。

### PEG文法

本では解析表現文法により定義された構文規則をPEG文法と呼ぶ。解析表現文法の構文規則はパターンを記述する式 $e$ に対して名前 $A$ を与えることで定義する。本書ではこのことを $A=e$ と記述する。構文規則の名前 $A$ は**非終端記号**、パターン記述式 $e$ を**解析表現**と呼ぶ。解析表現でもEBNF同様の構文が使えるが、順序付き選択を導入したことにより繰り返しの解釈は **貪欲な繰り返し** となっている。

解析表現では生成文法と異なり**部分マッチ**を採用している。これは入力文字列の先頭にマッチした場合、文字列全体に一致しなくてもマッチに成功したとみなす方式である。

順序付き選択。交換法則が一般には成り立たない。成り立たないケースは「 $e_1 / e_2$ に関して $e_1$ と $e_2$ が重なる場合」である。ここで「重なる」とは、 $e_1$ , $e_2$ が同じ文字列にマッチしようとしているパターンを指す。マッチする文字列が重ならない場合は交換法則が成り立つ。また、分配法則は右分配法則が一般に成り立たない。

貪欲マッチ（最長マッチ）。`a* a`のようなパターンは `aaa` にマッチしない（BNFではマッチする）。これは最初の `a*` が入力をすべて消費してしまい、続く `a` でマッチする文字が残っていないためである。構文解析では最長マッチが自然であるケースが多いと言われている。

### PEGのパターンマッチ手順

- 解析表現文法は順序付き選択が決定的であるためパターンマッチ手順（構文解析アルゴリズム）も決定的
- 有限状態オートマトンと同様1文字ずつ処理が進む
  - 順序付き選択では、たとえばマッチしなかった文字があるとバックトラッキングで次の順序付き選択文字がマッチを試される
- 未消費文字列がお残っていても解析表現の終端に到達すれば解析完了（マッチ成功）となる
  - 未消費文字列を許したくない場合は末尾に `!.` を追加する

## 第4章 構文木とPegTree

本章からPegTreeという著者の作ったPEGパーサジェネレータを利用する。PEGの実装方式は複数存在するが、PegTreeはキャプチャ方式で実装されている。

PegTreeの便利機能として構文木にノードを追加できるようになっている。構文木ノードはキャメルケース、純粋なパターンはすべて大文字で命名を行う。

構文木アノテーションを使って不要な字句を除外した構文木を構築できる。こうした意味解析に不要な情報を除いた構文木を抽象構文木と呼ぶ。

メモ: 52ページのコード、`frac:`ラベルを書くべきところの行が脱落している。
